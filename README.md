# Homework 1 SCD - Client/Server aplication for OAuth authorization with RPC

The Homework consists in implementing a Client - Server aplication using the concept of Remote Procedure Call
to simulate an authorization system type OAuth.

The whole process consists into a client that wants to perform an operation on a server. To do that, the client first needs to send a request to receive authorization and access tokens. When they request the authorization token, the End-User will approve or deny their request. If they approve it, they will also give them a list of permissions for the resources.
Once that's done, the client can request an access token. If that's active, the client has permission to attempt to do an action. Once they try to execute an action, the client will receive a response from the server about wether or not that was a success. If it was denied, it will get the reason why as well (such as "Permission Denied", or "Operation not permited" and so on).

According to the ``check.sh`` offered by the homework, it passes all the given tests.

It should be enough to just call a ``make`` and then running ``tema1_server`` and ``tema1_client``. **NO NEED** to run rpcgen.

Now to the actual implementation of this.

## tema1.x

Represents the rpc interfation where we define the functions through which the client and the server interact, while also defining the structures used.

In this one we have:
- structures used for requesting an authorization token: ``req_authorization_return``:
  - ``id`` -> the id of the client that requests it.
  - ``auth_token`` -> the auth token generated by the server
  - ``valid`` -> wether or not the client is in the database or not
  - ``approved`` -> wether or not the client is approved by the end-user
- structures used for requesting an access token: ``req_access_param``, ``req_access_return``, ``req_access_refresh_return``:
  - they contain the ``id`` and ``auth_token`` that the other authorization token structures contains
  - ``req_access_return`` adds the field for the ``access_token`` generated by the server, for when we don't have refresh activated
  - ``req_access_refresh_return`` adds the field for the ``refresh_token`` generated by the server, for when we have refresh activated.
- structures used to validate the operations done by the client on a specific resource: ``action_param``, ``validate_action_return``:
  - contains the ``id``/``id_client`` present in the other structs
  - contains the ``access_token`` present in the other structs, also serving as a way for the client to update the access token in case it gets regenerated because of refresh active.
  - ``resource`` -> the resource accessed for the given operation
  - ``operation_type`` -> what operation the client wants to do on the given resource
  - ``refresh_token`` -> in case the token needs to be refreshed, it will be updated in this field for the client to update in on its side as well
  - ``result`` -> the message that the server gives to the client, ranging from "Permision granted" to "User not found".
- structures used to approve a client by the end-user: ``approve_req_token_return``:
  - contains the ``access_token`` present in other structures
  - ``permissions`` -> gives the list of permissions that the client has
  - ``approved`` -> wether or not the end-user approves the client

Based on the name of the structures, we have the ones that are used for the parameters of the functions and others that are used as the return-type of the functions.

The interface implements 5 functions in total:
- ``REQ_AUTH`` -> request authorization token
- ``REQ_ACCESS`` -> request access token
- ``VALIDATE_ACTION`` -> check if the client can/can't do an operation on a resource
- ``APPROVE_TOKEN`` -> end-user approves/doesn't approve the client
- ``REQ_ACCESS_REFR`` -> request access token and refresh token

## tema1_svc

The file is *mostly* generated by the rpcgen. The only adition is that it also calls the function used to initialize the server, written in ``tema1_server.c``.

The function is ``void init_server(int argc, char **argv)`` and is called right before ``svc_run()`` in the main code. I've done this so that the server can *actually* grab all the information it needs from the file before it starts receiving calls from the client.

## tema1_client.c

The client mostly deals with parsing lines from the input line and saving the specific information that the server sends it back to him, while also requesting things to the server.

For the internal database of the client we have a struct ``client`` that saves the id of the client and the authorization, access and refresh tokens of a client. The client application then stores all of this in an array.

For taking each and every action in the input file, the client goes through each line 'till the end of the file and then calls the ``parse_action`` function. This function will break the string into comma-seperated tokens and check what each token has. 

parse_action:
1. Gets the token that tells us the id of the client, the first word of the input line
2. Check if we have the client already, if not, create a new client variable and save the id
3. Gets the next token which determines what action we have to do
4. If it's request, grab the refresh variable and call the ``request_action`` function
5. If it's not a request, grab the resource that's accessed and call ``validate_action`` function

``request_action`` will then fill up the variables needed for the parameters of the functions used to communicate with the server and then update the internal database with all the new tokens it has generated

``validate_action`` will sent the action to the server and print what the answer was, while also updating the access and refresh tokens if needed.

## tema1_server.c

The server also has its own ``client`` structure, but, compared to the client-side one, it has a lot more information stored in it. Besides the fields the client-side one has, it also stores how many actions can the client do with the current access token (``valability``), wether or not the client is approved by the end-user (``approved``), all the permissions that the client currently has (``permissions``) and wether or not the client has a refresh token (``refresh``).

Other than that, the server has an array where it saves a list of all the available resources (``resources``), an array where it saves a list of all the clients (``clients``), and specific variables to make things much easier, such as what's the maximum amount of actions a token can take (``max_valability``) or how many requests have been made so far (``request_counter``).

Functions wise, I'll go through each of the important ones and explain what they do in a few words:

``init_server``: Initializes the server by reading all the input files given and fills up the database with the information received. For now, the clients database will only have clients with only the ``id`` field completed. Called before the server actually runs by "exporting" it into ``tema1_svc.c`` and calling it before the ``svc_run`` call.

``req_auth_1_svc``: First checks to see if the client exists, before generating the authorization token for the client. Afterwards, it calls the function that checks if the end-user approves the request and updates the fields for ``id``, ``auth_token``, ``approved`` and ``permissions`` for the specific client in the database.

``req_access_1_svc``: Generates the access token and updates the fields of ``access_token`` and ``valability`` for the given client. The valability will be equal to ``max_valability``.

``req_access_refr_1_svc``: Generates the access token and the refresh token, updates the neccesary fields in the database for the specific client.

``validate_action_1_svc``: First, checks wether or not the client has an access token generated (``PERMISION_DENIED`` if it doesn't exist). Afterwards, checks if the access token given is the same as the one the server has in its database (``PERMISSION_DENIED`` if it doesn't exist). The next step is to check if the client can still do actions with the token it has. If the refresh is active, we'll regenerate the access and refresh token. If not, we'll send the response to the client of ``TOKEN_EXPIRED``. Once the valability is checked, we make sure that the resource the client wants to access exists. If not, we send the ``RESOURCE_NOT_FOUND`` response. Once that's done, we call ``check_permission`` which goes through the permissions of the client and check each and every resource it has access to 'till we find the one that it wants to operate on. After that, we go through the string that gives us the operation it can do on the resource and check if the one it wants to do is there. For everything but ``EXECUTE`` we check if the first letter of the operation is the same as a letter in the permissions, but for execute we check the second letter of the operation. Once everything is checked we can send ``PERMISSION_GRANTED`` to the client or, if something went wrong (client can't do the operation on the resource) we send the ``OPERATION_NOT_PERMITED``. At the end of everything, we send the result with the new tokens (if they were regenerated) back to the client.

``approve_token_1_svc``: Using the request_counter, we grab that specific line from the file with the end-users responses and check to see if they approve. If they do, we save the permissions and send them, if not, we send the response to the client.

Other small functions that there are in the server are ``check_id`` which returns the client with the specific id, ``check_resources`` which returns the resource with the specific name and ``refresh_change`` which regenerates the refresh and access tokens when it's needed.
